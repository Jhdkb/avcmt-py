# File: avcmt/commit.py
import os
import subprocess
from collections import defaultdict
from datetime import datetime

from jinja2 import Environment, FileSystemLoader

from avcmt.ai import generate_with_ai
from avcmt.utils import extract_commit_messages_from_md, is_recent_dry_run


def get_changed_files():
    result = subprocess.run(
        ["git", "status", "--porcelain"],
        stdout=subprocess.PIPE,
        text=True,
        encoding="utf-8",
        errors="replace",
        check=False,
    )
    files = []
    for line in result.stdout.strip().split("\n"):
        if not line:
            continue
        status, path = line[:2], line[3:]
        path = path.strip()
        if ("D" not in status and os.path.exists(path)) or (
            "??" in status and os.path.exists(path)
        ):
            files.append(path)
    return files


def group_files_by_directory(files):
    grouped = defaultdict(list)
    for file_path in files:
        parent_dir = os.path.dirname(file_path) or "root"
        grouped[parent_dir].append(file_path)
    return grouped


def get_diff_for_files(files, staged=True):
    if staged:
        result = subprocess.run(
            ["git", "--no-pager", "diff", "--staged"] + files,
            stdout=subprocess.PIPE,
            text=True,
            encoding="utf-8",
            errors="replace",
            check=False,
        )
        if not result.stdout.strip():
            result = subprocess.run(
                ["git", "--no-pager", "diff"] + files,
                stdout=subprocess.PIPE,
                text=True,
                encoding="utf-8",
                errors="replace",
                check=False,
            )
        return result.stdout
    result = subprocess.run(
        ["git", "--no-pager", "diff"] + files,
        stdout=subprocess.PIPE,
        text=True,
        encoding="utf-8",
        errors="replace",
        check=False,
    )
    return result.stdout


def render_prompt(group_name, diff_text):
    template_dir = os.path.join(os.path.dirname(__file__), "prompt_templates")
    env = Environment(loader=FileSystemLoader(template_dir))
    template = env.get_template("commit_message.j2")
    return template.render(group_name=group_name, diff_text=diff_text)


def run_commit_group_all(
    dry_run=False, push=False, debug=False, provider="pollinations", model="gemini", logger=None, **kwargs
):
    if logger:
        logger.info(f"Starting run_commit_group_all: dry_run={dry_run}, push={push}, debug={debug}")
    
    files = get_changed_files()
    if not files:
        print("No changed files detected.")
        return

    os.makedirs("log", exist_ok=True)
    dry_run_file = os.path.join("log", "commit_messages_dry_run.md")
    use_cache = not dry_run and is_recent_dry_run(dry_run_file)
    cached_messages = extract_commit_messages_from_md(dry_run_file) if use_cache else {}
    grouped_files = group_files_by_directory(files)

    # Init dry-run .md if needed
    if dry_run:
        with open(dry_run_file, "w", encoding="utf-8") as f:
            ts = datetime.now().astimezone().strftime("%Y-%m-%d %H:%M:%S (%Z)")
            f.write("# AI Semantic Release Commit Messages (Dry Run)\n")
            f.write(f"_Last generated: {ts}_\n\n")
            f.write("Automatically generated by `avcmt --dry-run`\n\n")

    # Process per group
    for group_name, group in grouped_files.items():
        diff = get_diff_for_files(group)
        if not diff.strip():
            print(f"[SKIP] No changes detected for {group_name}.")
            continue

        if group_name in cached_messages:
            commit_message = cached_messages[group_name]
            print(f"[CACHED] Using cached message for **{group_name}**:\n{commit_message}")
        else:
            prompt = render_prompt(group_name, diff)
            commit_message = generate_with_ai(
                prompt, provider=provider, model=model, debug=debug, **kwargs
            )

        print(f"\nSuggested commit message for **{group_name}**:\n{commit_message}\n")

        if dry_run:
            with open(dry_run_file, "a", encoding="utf-8") as f:
                f.write(f"## Group: `{group_name}`\n\n```md\n{commit_message}\n```\n\n---\n\n")
        else:
            subprocess.run(["git", "add"] + group, check=False)
            subprocess.run(["git", "commit", "-m", commit_message], check=False)

    # Catch-all (non dry-run only)
    if not dry_run:
        remaining_files = get_changed_files()
        if remaining_files:
            print(f"Some files are still staged after per-directory commits: {remaining_files}")
            subprocess.run(["git", "add"] + remaining_files, check=False)
            catchall_diff = get_diff_for_files(remaining_files)

            if catchall_diff and len(catchall_diff) < 12000:
                if "catch-all" in cached_messages:
                    catchall_message = cached_messages["catch-all"]
                    print(f"[CACHED] Using cached message for **catch-all**:\n{catchall_message}")
                else:
                    catchall_prompt = render_prompt("catch-all", catchall_diff)
                    catchall_message = generate_with_ai(
                        catchall_prompt, provider=provider, model=model, debug=debug, **kwargs
                    )
            else:
                catchall_message = (
                    "chore: catch-all commit for files missed by grouped auto-commit\n\n"
                    "Auto-commit for any files that were staged or modified after group commits."
                )

            subprocess.run(["git", "commit", "-m", catchall_message], check=False)

    # Optional push
    if push and not dry_run:
        print("\nPushing all commits to the active remote branch...")
        subprocess.run(["git", "push"], check=False)
        print("✔️ All changes pushed to the remote branch.")

    if dry_run:
        print(f"\n[DRY RUN COMPLETED] All commit messages are saved to: {dry_run_file}")


# Export function for CLI import
__all__ = ["run_commit_group_all"]
